#!/usr/bin/env ruby

require "bundler"
require "bundler/inline"
require "time"

Bundler.configure

gemfile do
  source "https://rubygems.org"
  gem "amazing_print"
  gem "cri"
  gem "dotenv", require: "dotenv/load"
  gem "flickr"
end

def list_portfolios(flickr, user, directory, write)
  flickr.photosets.getList(user_id: user)["photoset"].each do |set|
    is_portfolio = set["title"] =~ /portfolio/i && set["count_photos"] > 0

    puts "\n[%1<portfolio>s] %<user>s / %<title>s : %<photos>d photo(s), updated %<updated>s" % {
      user: set["username"],
      title: set["title"],
      portfolio: is_portfolio ? "x" : "",
      photos: set["count_photos"],
      updated: Time.strptime(set["date_update"], "%s")
    }

    if is_portfolio
      flickr.photosets.getPhotos(user_id: user, photoset_id: set["id"], media: :photos)["photo"].each do |photo|
        info = flickr.photos.getInfo(photo_id: photo["id"], secret: photo["secret"])
        # sizes = flickr.photos.getSizes(photo_id: photo["id"])
        # may throw error # exif = flickr.photos.getExif(photo_id: photo["id"], secret: photo["secret"])["exif"]
        # may throw error # location = flickr.photos.geo.getLocation(photo_id: photo["id"], secret: photo["secret"])

        puts "    %-40<title>s : %<taken>s, %4<views>d views, %3<comments>d comments, %<updated>s" % {
          title: photo["title"].length <= 40 ? photo["title"] : photo["title"].sub(/^(.{39}).*/, "\\1â€¦"),
          taken: info["dates"]["taken"],
          views: info["views"],
          comments: info["comments"],
          updated: Time.strptime(info["dates"]["lastupdate"], "%s")
        }
      end
    end
  end
end

module PhotoPort
  class Command
    class Runner < Cri::CommandRunner
      def run
        key = options[:key] || ENV["FLICKR_API_KEY"]
        secret = options[:secret] || ENV["FLICKR_API_SHARED_SECRET"]
        user = options[:user] || ENV["FLICKR_USER_NSID"]
        flickr = Flickr.new(key, secret)
        list_portfolios(flickr, user, options[:dir], options[:write])
      end
    end

    def initialize
      @command = define_command
    end

    def define_command
      Cri::Command.define do
        name $PROGRAM_NAME.to_s
        usage "#{$PROGRAM_NAME} [--key=API_KEY] [--secret=API_SECRET] [--user=ID] [--write]"
        summary "List Flickr user's portfolio albums/photosets and their photos"
        description <<~EOS
          List the public portofolio albums or photosets of a Flickr user, using the Flickr API (https://www.flickr.com/services/api/).

          With flag '--write', write Markdown/HTML files of portfolio gallery pages, and individual photos.

          The Flickr API requires an API key and shared secret from your Flickr account. You can create them by logging in to Flickr, and creating an application at https://www.flickr.com/services/apps/create/apply.

          You have three ways to provide the Flickr API key, shared secret, and Flickr user ID of the owner of albums/photosets: (mix as you like)

          (1) Commandline options -k/--key, -s/--secret, -u/--user (highest priority)

          (2) Environment variables FLICKR_API_KEY, FLICKR_API_SHARED_SECRET, FLICKR_USER_NSID

          (3) File '.env' in the current directory with variables FLICKR_API_KEY, FLICKR_API_SHARED_SECRET, FLICKR_USER_NSID. '.env' is parsed by rrubygem 'dotenv' (see https://www.rubydoc.info/gems/dotenv#usage). (lowest priority)
        EOS

        runner Runner
        option :k, :key, "Flickr API key; or $FLICKR_API_KEY (in .env)", argument: :required
        option :s, :secret, "Flickr API shared secret; or $FLICKR_API_SHARED_SECRET (in .env)", argument: :required
        option :u, :user, "Flickr user ID / NSID; or $FLICKR_USER_NSID (in .env)", argument: :required
        option :d, :dir, "Directory to write the markdown pages", argument: :required, default: "./src/portfolio"
        flag :w, :write, "Write markdown pages, overwrite existing markdown files"
        flag :h, :help, "show help for this command" do |_value, cmd|
          puts cmd.help
          exit 0
        end
      end
    end

    def run(opts_and_args)
      @command.run(opts_and_args)
    end
  end
end

# Monkey patch Cri::HelpRenderer::LINE_WIDTH to terminal width detected by IO.console.winsize
if $stdout.tty? && ENV["TERM"] != "dump"
  require "io/console"
  if IO.console.winsize
    module Cri
      class HelpRenderer
        send :remove_const, :LINE_WIDTH
        LINE_WIDTH = IO.console.winsize.last
      end
    end
  end
end

PhotoPort::Command.new.run(ARGV) if __FILE__ == $0
