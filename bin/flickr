#!/usr/bin/env ruby

require "bundler"
require "bundler/inline"

Bundler.configure

gemfile do
  source "https://rubygems.org"
  gem "amazing_print"
  gem "dotenv", require: "dotenv/load"
  gem "flickr"
  gem "thor"
end

module PhotoPort
  class CommandLine < Thor
    class_option :key, desc: "Flickr API key; or $FLICKR_API_KEY (in .env)"
    class_option :secret, desc: "Flickr API shared secret; or $FLICKR_API_SHARED_SECRET (in .env)"
    class_option :user, desc: "Flickr user ID / NSID; or $FLICKR_USER_NSID (in .env)"
    class_option :sort, desc: "Sorting order of photos", default: "set", enum: %w[set taken views comments]

    desc "list", "List the portfolio albums/photosets and photos."
    def list
      puts "There will be a list ..."
      key = options[:key] || ENV["FLICKR_API_KEY"]
      secret = options[:secret] || ENV["FLICKR_API_SHARED_SECRET"]
      user = options[:user] || ENV["FLICKR_USER_NSID"]
      list_portfolios(key, secret, user)
    end

    desc "write", "Write markdown pages for the portfolio albums/photosets and photos."
    option :dir, desc: "Directory to write the markdown pages", default: "./src/portfolio"
    option :force, type: :boolean, desc: "Write markdown pages, overwriting existing markdown files", default: false
    def write
      puts "There will be pages in #{options[:dir]} sorted by #{options[:sort]} ... with force:#{options[:force]} ..."
    end

    def self.exit_on_failure?
      true
    end
  end
end

def list_portfolios(key, secret, user)
  flickr = Flickr.new(key, secret)
  flickr.photosets.getList(user_id: user)["photoset"].each do |set|
    is_portfolio = set["title"] =~ /portfolio/i && set["count_photos"] > 0

    puts "\n[%1<portfolio>s] %<user>s / %<title>s : %<photos>d photo(s)" % {
      user: set["username"],
      title: set["title"],
      portfolio: is_portfolio ? "x" : "",
      photos: set["count_photos"]
    }

    continue unless is_portfolio

    flickr.photosets.getPhotos(user_id: user, photoset_id: set["id"], media: :photos)["photo"].each do |photo|
      info = flickr.photos.getInfo(photo_id: photo["id"], secret: photo["secret"])
      # sizes = flickr.photos.getSizes(photo_id: photo["id"])
      # may throw error # exif = flickr.photos.getExif(photo_id: photo["id"], secret: photo["secret"])["exif"]
      # may throw error # location = flickr.photos.geo.getLocation(photo_id: photo["id"], secret: photo["secret"])

      puts "    %-40<title>s : %<taken>s, %4<views>d views, %3<comments>d comments" % {
        title: photo["title"].length <= 40 ? photo["title"] : photo["title"].sub(/^(.{39}).*/, "\\1â€¦"),
        taken: info["dates"]["taken"],
        views: info["views"],
        comments: info["comments"]
      }
    end
  end
end

PhotoPort::CommandLine.start(ARGV) if __FILE__ == $0
