#!/usr/bin/env ruby

require "bundler"
require "bundler/inline"
require "fileutils"
require "json"
require "time"

Bundler.configure

gemfile do
  source "https://rubygems.org"
  gem "amazing_print"
  gem "cri"
  gem "dotenv", require: "dotenv/load"
  gem "gitlab_chronic_duration"
  gem "flickr"
end

def list_portfolios(flickr, user, cache_dir, cache_retention_seconds)
  photosets_cache = "#{cache_dir}/photosets.json"
  puts "fetching photosets for user #{user}"
  photosets = flickr.photosets.getList(user_id: user)["photoset"].map { |response| response.to_hash }

  FileUtils.mkdir_p(File.dirname(photosets_cache))
  File.write(photosets_cache, JSON[photosets])

  photosets.each do |set|
    photoset_photos_cache = "#{cache_dir}/photoset/#{set["id"]}.json"
    photoset_photos_cache_time = Time.strptime(set["date_update"], "%s")
    photoset_photos = nil

    if File.exist?(photoset_photos_cache) && photoset_photos_cache_time <= File.mtime(photoset_photos_cache)
      puts "photoset #{set["id"]} photo list cached in #{photoset_photos_cache} (updated #{photoset_photos_cache_time})"
      photoset_photos = JSON.load_file(photoset_photos_cache)
    else
      puts "fetching photoset #{set["id"]} photo list"
      photoset_photos = flickr.photosets.getPhotos(user_id: user, photoset_id: set["id"], media: :photos)["photo"].map { |response| response.to_hash }

      FileUtils.mkdir_p(File.dirname(photoset_photos_cache))
      File.write(photoset_photos_cache, JSON[photoset_photos])
      File.utime(photoset_photos_cache_time, photoset_photos_cache_time, photoset_photos_cache)
    end

    photoset_photos&.each do |photo|
      photo_cache = "#{cache_dir}/photo/#{photo["id"]}.json"

      if File.exist?(photo_cache) && File.ctime(photo_cache) > (Time.now - cache_retention_seconds)
        puts "photo #{photo["id"]} info cached in #{photo_cache} (updated #{File.ctime(photo_cache)})"
      else
        puts "fetching photo #{photo["id"]} info"
        info = flickr.photos.getInfo(photo_id: photo["id"], secret: photo["secret"]).to_hash.transform_values { |value| value.respond_to?(:to_hash) ? value.to_hash : value }
        photo_cache_time = Time.strptime(info["dates"]["lastupdate"], "%s")

        if !File.exist?(photo_cache) || photo_cache_time > File.mtime(photo_cache)
          puts "fetching photo #{photo["id"]} exif"
          exif = nil
          begin
            exif = flickr.photos.getExif(photo_id: photo["id"], secret: photo["secret"])
          rescue
          end
          info["exif"] = exif && exif["exif"].map { |value| value.respond_to?(:to_hash) ? value.to_hash : value }

          puts "fetching photo #{photo["id"]} location"
          location = nil
          begin
            location = flickr.photos.geo.getLocation(photo_id: photo["id"], secret: photo["secret"])
          rescue
          end
          info["location"] = location && location["location"].to_hash

          puts "fetching photo #{photo["id"]} sizes"
          sizes = nil
          begin
            sizes = flickr.photos.getSizes(photo_id: photo["id"])
          rescue
          end
          info["sizes"] = sizes && sizes["size"].map { |value| value.to_hash }

          FileUtils.mkdir_p(File.dirname(photo_cache))
          File.write(photo_cache, JSON[info])
          File.utime(photo_cache_time, photo_cache_time, photo_cache)
        else
          puts "photo #{photo["id"]} info cached in #{photo_cache} (update #{photo_cache_time})"
        end
      end
    end
  end
end

module PhotoPort
  module Flickr
    class Command
      class Runner < Cri::CommandRunner
        def run
          ChronicDuration.raise_exceptions = true

          cache_dir = options[:cache] || ENV["FLICKR_CACHE"]
          cache_retention_seconds = ChronicDuration.parse(options[:retention] || ENV["FLICKR_RETENTION"])
          empty_cache = options[:"empty-cache"] || %w[t true y yes 1].include?(ENV["FLICKR_EMPTY_CACHE"]&.downcase)
          key = options[:key] || ENV["FLICKR_KEY"]
          secret = options[:secret] || ENV["FLICKR_SECRET"]
          user = options[:user] || ENV["FLICKR_USER"]

          flickr = ::Flickr.new(key, secret)
          FileUtils::Verbose.rm_r(cache_dir, secure: true) if empty_cache
          list_portfolios(flickr, user, cache_dir, cache_retention_seconds)
        end
      end

      def initialize
        @command = define_command
      end

      def define_command
        Cri::Command.define do
          name $PROGRAM_NAME.to_s
          usage "#{$PROGRAM_NAME} [--key=API_KEY] [--secret=API_SECRET] [--user=ID] [--write]"
          summary "List Flickr user's portfolio albums/photosets and their photos"
          description <<~EOS
            List the public portofolio albums or photosets of a Flickr user, using the Flickr API (https://www.flickr.com/services/api/).

            With flag '--write', write Markdown/HTML files of portfolio gallery pages, and individual photos.

            The Flickr API requires an API key and shared secret from your Flickr account. You can create them by logging in to Flickr, and creating an application at https://www.flickr.com/services/apps/create/apply.

            You have three ways to provide option values: (mix as you like)

            (1) Commandline options like -k/--key, -s/--secret, -u/--user, etc. (highest priority)

            (2) Environment variables like FLICKR_KEY, FLICKR_SECRET, FLICKR_USER, etc.

            (3) File '.env' in the current directory with variables FLICKR_KEY, FLICKR_SECRET, FLICKR_USER, etc. '.env' is parsed by rrubygem 'dotenv' (see https://www.rubydoc.info/gems/dotenv#usage). (lowest priority)
          EOS

          runner Runner
          option :k, :key, "Flickr API key; or $FLICKR_KEY (in .env)", argument: :required
          option :s, :secret, "Flickr API shared secret; or $FLICKR_SECRET (in .env)", argument: :required
          option :u, :user, "Flickr user ID / NSID; or $FLICKR_USER (in .env)", argument: :required
          option :c, :cache, "Directory to cache Flickr API results; or $FLICKR_CACHE", argument: :required, default: "src/_data/flickr"
          option :r, :retention, "Minimum retention of photo cache in cache directory; or $FLICKR_RETENTION", argument: :required, default: "1 day"
          flag nil, :"empty-cache", "Remove all cached Flickr API results in cache directory; or $FLICKR_EMPTY_CACHE"
          flag :h, :help, "show help for this command" do |_value, cmd|
            puts cmd.help
            exit 0
          end
        end
      end

      def run(opts_and_args)
        @command.run(opts_and_args)
      end
    end
  end
end

# Monkey patch Cri::HelpRenderer::LINE_WIDTH to terminal width detected by IO.console.winsize
if $stdout.tty? && ENV["TERM"] != "dump"
  require "io/console"
  if IO.console.winsize
    module Cri
      class HelpRenderer
        send :remove_const, :LINE_WIDTH
        LINE_WIDTH = IO.console.winsize.last
      end
    end
  end
end

PhotoPort::Flickr::Command.new.run(ARGV) if __FILE__ == $0
